# Overview

MyFi QR Connect is a minimal Flask web application that generates Wi-Fi QR codes. Users input their Wi-Fi network name (SSID) and password, and the app generates a QR code using the WIFI: URI scheme. When scanned by modern smartphones (Android/iOS), the device automatically connects to the Wi-Fi network without manually exposing the password.

The application serves a simple, single-purpose function: securely share Wi-Fi credentials via QR codes with a visually appealing pink AMOLED glass-style interface.

# Recent Changes

**October 10, 2025**
- Fixed CSS layout by adding missing `.container` class for proper HTML structure
- Corrected port configuration to use 5000 (Replit standard) instead of 8080
- Installed Python 3.11 and all required dependencies (Flask, qrcode, Pillow)
- Set up Flask Server workflow with webview output
- Verified QR code generation working correctly with test credentials
- Updated README with complete documentation and testing verification

# User Preferences

Preferred communication style: Simple, everyday language.

# System Architecture

## Frontend Architecture

**Single-Page Application with Server-Side Rendering**
- Uses Flask's Jinja2 templating engine to render HTML
- Single template (`index.html`) handles both the input form and QR code display
- Form submission triggers a POST request to generate the QR code
- QR code is embedded as a base64-encoded PNG image directly in the HTML response

**Styling Approach**
- Static CSS file with glass-morphism design aesthetic
- Pink gradient background with glassmorphic card overlay
- Poppins font loaded from Google Fonts CDN
- Responsive design centered for various screen sizes

## Backend Architecture

**Flask Web Framework**
- Lightweight Python web framework chosen for simplicity and minimal overhead
- Two routes:
  - `GET /` - Renders the main input form
  - `POST /generate_qr` - Processes form data and returns the page with QR code
- No session management or user authentication required
- Stateless request handling (each QR generation is independent)

**QR Code Generation**
- Uses `qrcode` library to create QR code images
- Follows the WIFI: URI scheme format: `WIFI:T:{security};S:{ssid};P:{password};;`
- Supports WPA security type (default)
- QR code is generated in-memory using `io.BytesIO` buffer
- Image is base64-encoded and embedded directly in HTML (no file storage)

**Design Rationale**
- In-memory processing avoids file system dependencies
- Base64 embedding eliminates need for static file serving of generated images
- No temporary file cleanup required
- Immediate display without additional HTTP requests

## Data Storage

**No Persistent Storage**
- Application is completely stateless
- No database, file system, or cache layer
- Wi-Fi credentials are only held in memory during request processing
- QR codes are generated on-demand and discarded after response

**Security Consideration**
- No logging of sensitive Wi-Fi credentials
- Credentials exist only during the HTTP request lifecycle
- No history or audit trail of generated QR codes

## Deployment Configuration

**Replit-Specific Setup**
- Configured to run on host `0.0.0.0` and port `5000`
- Debug mode enabled for development environment
- Port 5000 is hardcoded for Replit compatibility

# External Dependencies

## Python Libraries

**Flask** - Web framework for routing and templating
- Provides request handling and Jinja2 template rendering
- Minimal setup required for single-page applications

**qrcode** - QR code generation library
- Creates QR code images from text strings
- Handles WIFI: URI scheme encoding

**Pillow (PIL)** - Image processing library
- Required dependency for qrcode to generate PNG images
- Handles image format conversion and in-memory buffering

## External Services

**Google Fonts CDN**
- Loads Poppins font family for typography
- Single external HTTP dependency for styling
- Fallback to system fonts if CDN unavailable

## No Database or Authentication Services

The application has no database connections, user authentication systems, or third-party API integrations. It operates as a standalone utility with minimal external dependencies.